<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>마인크래프트 에이전트 제어</title>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://unpkg.com/blockly/blockly.min.js"></script>
    <script src="https://unpkg.com/blockly/javascript_compressed.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            display: flex;
            height: 100vh;
            background-color: #f3f4f6;
        }

        .workspace {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: white;
            position: relative;
        }

        #blocklyDiv {
            flex: 1;
            position: relative;
        }

        .control-panel {
            padding: 10px;
            background-color: #f8f9fa;
            border-top: 1px solid #e5e7eb;
            display: flex;
            gap: 10px;
        }

        button {
            padding: 8px 16px;
            background-color: #10B981;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #059669;
        }

        button.stop-button {
            background-color: #DC2626;
        }

        button.stop-button:hover {
            background-color: #B91C1C;
        }

        button.disconnect-button {
            background-color: #6B7280;
        }

        button.disconnect-button:hover {
            background-color: #4B5563;
        }

        #notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        #notification.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="workspace">
        <div id="blocklyDiv"></div>
        <div class="control-panel">
            <button class="stop-button" onclick="stopExecution()">실행 중지</button>
            <button class="disconnect-button" onclick="socket.emit('stop'); window.close();">연결 끊기</button>
        </div>
    </div>

    <div id="notification"></div>

    <xml id="toolbox" style="display: none">
        <category name="플레이어" colour="#60A5FA">
            <block type="on_chat_command"></block>
            <block type="text_print">
                <value name="TEXT">
                    <shadow type="text">
                        <field name="TEXT">안녕하세요!</field>
                    </shadow>
                </value>
            </block>
            <block type="text_join">
                <mutation items="2"></mutation>
                <value name="ADD0">
                    <shadow type="text">
                        <field name="TEXT">첫번째</field>
                    </shadow>
                </value>
                <value name="ADD1">
                    <shadow type="text">
                        <field name="TEXT">두번째</field>
                    </shadow>
                </value>
            </block>
        </category>
        <category name="에이전트" colour="#D83B01">
            <block type="agent_spawn"></block>
            <block type="agent_tp"></block>
            <block type="agent_tp_pos">
                <value name="POSITION">
                    <shadow type="coordinate_pos">
                        <value name="X">
                            <shadow type="math_number">
                                <field name="NUM">0</field>
                            </shadow>
                        </value>
                        <value name="Y">
                            <shadow type="math_number">
                                <field name="NUM">0</field>
                            </shadow>
                        </value>
                        <value name="Z">
                            <shadow type="math_number">
                                <field name="NUM">0</field>
                            </shadow>
                        </value>
                    </shadow>
                </value>
            </block>
            <block type="agent_move">
                <value name="DISTANCE">
                    <shadow type="math_number">
                        <field name="NUM">1</field>
                    </shadow>
                </value>
            </block>
            <block type="agent_turn"></block>
            <block type="agent_destroy"></block>
            <block type="agent_attack"></block>
            <block type="agent_place"></block>
            <block type="agent_collect"></block>
            <block type="agent_set_slot">
                <value name="SLOT">
                    <shadow type="math_number">
                        <field name="NUM">1</field>
                    </shadow>
                </value>
            </block>
            <block type="agent_drop_all"></block>
            <block type="agent_drop_slot"></block>
            <block type="agent_till"></block>
        </category>
        <category name="블록" colour="#7ABB55">
        </category>
        <category name="위치" colour="#69b090">
            <block type="coordinate_pos">
                <value name="X">
                    <shadow type="math_number">
                        <field name="NUM">0</field>
                    </shadow>
                </value>
                <value name="Y">
                    <shadow type="math_number">
                        <field name="NUM">0</field>
                    </shadow>
                </value>
                <value name="Z">
                    <shadow type="math_number">
                        <field name="NUM">0</field>
                    </shadow>
                </value>
            </block>
            <block type="world_pos">
                <value name="X">
                    <shadow type="math_number">
                        <field name="NUM">0</field>
                    </shadow>
                </value>
                <value name="Y">
                    <shadow type="math_number">
                        <field name="NUM">0</field>
                    </shadow>
                </value>
                <value name="Z">
                    <shadow type="math_number">
                        <field name="NUM">0</field>
                    </shadow>
                </value>
            </block>
        </category>
        <category name="반복" colour="#55833C">
            <block type="custom_repeat">
                <value name="TIMES">
                    <shadow type="math_number">
                        <field name="NUM">4</field>
                    </shadow>
                </value>
            </block>
        </category>
        <category name="계산" colour="#4c4d70">
            <block type="math_number">
                <field name="NUM">0</field>
            </block>
            <block type="math_arithmetic">
                <field name="OP">ADD</field>
                <value name="A">
                    <shadow type="math_number">
                        <field name="NUM">1</field>
                    </shadow>
                </value>
                <value name="B">
                    <shadow type="math_number">
                        <field name="NUM">1</field>
                    </shadow>
                </value>
            </block>
            <block type="math_number_property">
                <mutation divisor_input="false"></mutation>
                <field name="PROPERTY">EVEN</field>
                <value name="NUMBER_TO_CHECK">
                    <shadow type="math_number">
                        <field name="NUM">0</field>
                    </shadow>
                </value>
            </block>
            <block type="math_round">
                <field name="OP">ROUND</field>
                <value name="NUM">
                    <shadow type="math_number">
                        <field name="NUM">3.1</field>
                    </shadow>
                </value>
            </block>
            <block type="math_modulo">
                <value name="DIVIDEND">
                    <shadow type="math_number">
                        <field name="NUM">64</field>
                    </shadow>
                </value>
                <value name="DIVISOR">
                    <shadow type="math_number">
                        <field name="NUM">10</field>
                    </shadow>
                </value>
            </block>            
        </category>
        <category name="논리" colour="#459197">
            <block type="controls_if"></block>            
            <block type="logic_compare">
                <field name="OP">EQ</field>
                <value name="A">
                    <shadow type="math_number">
                        <field name="NUM">0</field>
                    </shadow>
                </value>
                <value name="B">
                    <shadow type="math_number">
                        <field name="NUM">0</field>
                    </shadow>
                </value>
            </block>
            <block type="logic_operation">
                <field name="OP">AND</field>
            </block>
            <block type="logic_negate"></block>
            <block type="logic_boolean">
                <field name="BOOL">TRUE</field>
            </block>
            <block type="logic_null"></block>
            <block type="logic_ternary"></block>
        </category>
        <category name="변수" colour="#a41e16" custom="VARIABLE"></category>
    </xml>

    <script>
        //전역 변수 선언
        let socket = io();
        let workspace;
        let isExecuting = false;  // 실행 상태를 추적하는 변수
        let shouldStop = false;   // 중지 신호를 위한 변수

        // 블록 한글화
        function initBlockly() {
            // 변수 관련 메시지를 한글로 변경
            Blockly.Msg['NEW_VARIABLE'] = '변수 만들기';
            Blockly.Msg['NEW_VARIABLE_TITLE'] = '새 변수 이름:';
            Blockly.Msg['RENAME_VARIABLE'] = '변수 이름 바꾸기';
            Blockly.Msg['RENAME_VARIABLE_TITLE'] = '"%1" 변수의 이름을 바꾸기:';
            Blockly.Msg['DELETE_VARIABLE'] = '"%1" 변수 삭제';
            Blockly.Msg['DELETE_VARIABLE_CONFIRMATION'] = '"%2" 변수가 %1곳에서 사용되고 있습니다. 삭제하시겠습니까?';
            Blockly.Msg['VARIABLE_ALREADY_EXISTS'] = '"%1" 변수가 이미 존재합니다.';
            Blockly.Msg['VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE'] = '"%1" 변수가 다른 타입으로 이미 존재합니다: "%2"';
            
            // 변수 블록 메시지 변경
            Blockly.Msg['VARIABLES_SET'] = '%1 값을 %2 로 정하기';
            Blockly.Msg['VARIABLES_GET'] = '%1';
            Blockly.Msg['VARIABLES_CHANGE'] = '%1 값을 %2 만큼 바꾸기';
            Blockly.Msg['MATH_CHANGE_TITLE'] = '%1 값을 %2 만큼 바꾸기';

            // 수학 블록 메시지 한글화
            Blockly.Msg['MATH_ARITHMETIC_HELPURL'] = '';
            Blockly.Msg['MATH_ARITHMETIC_TOOLTIP_ADD'] = '두 수의 합을 반환합니다.';
            Blockly.Msg['MATH_ARITHMETIC_TOOLTIP_MINUS'] = '두 수의 차를 반환합니다.';
            Blockly.Msg['MATH_ARITHMETIC_TOOLTIP_MULTIPLY'] = '두 수의 곱을 반환합니다.';
            Blockly.Msg['MATH_ARITHMETIC_TOOLTIP_DIVIDE'] = '두 수의 나눗셈 결과를 반환합니다.';
            Blockly.Msg['MATH_ARITHMETIC_TOOLTIP_POWER'] = '첫 번째 수를 두 번째 수만큼 거듭제곱한 결과를 반환합니다.';
            Blockly.Msg['MATH_NUMBER_TOOLTIP'] = '숫자입니다.';
            Blockly.Msg['MATH_ADDITION_SYMBOL'] = '+';
            Blockly.Msg['MATH_SUBTRACTION_SYMBOL'] = '-';
            Blockly.Msg['MATH_MULTIPLICATION_SYMBOL'] = '×';
            Blockly.Msg['MATH_DIVISION_SYMBOL'] = '÷';
            Blockly.Msg['MATH_POWER_SYMBOL'] = '^';

            Blockly.Msg['MATH_NUMBER_PROPERTY_EVEN'] = '짝수';
            Blockly.Msg['MATH_NUMBER_PROPERTY_ODD'] = '홀수';
            Blockly.Msg['MATH_NUMBER_PROPERTY_PRIME'] = '소수';
            Blockly.Msg['MATH_NUMBER_PROPERTY_WHOLE'] = '정수';
            Blockly.Msg['MATH_NUMBER_PROPERTY_POSITIVE'] = '양수';
            Blockly.Msg['MATH_NUMBER_PROPERTY_NEGATIVE'] = '음수';
            Blockly.Msg['MATH_NUMBER_PROPERTY_DIVISIBLE_BY'] = '다음으로 나눌 수 있음:';
            
            Blockly.Msg['MATH_IS_TOOLTIP'] = '숫자가 짝수, 홀수, 소수, 정수, 양수, 음수인지 또는 특정 수로 나눌 수 있는지 검사합니다.';
            
            Blockly.Msg['MATH_ROUND_OPERATOR_ROUND'] = '반올림';
            Blockly.Msg['MATH_ROUND_OPERATOR_ROUNDUP'] = '올림';
            Blockly.Msg['MATH_ROUND_OPERATOR_ROUNDDOWN'] = '내림';
            
            Blockly.Msg['MATH_MODULO_TITLE'] = '%1 ÷ %2 의 나머지';
            Blockly.Msg['MATH_MODULO_TOOLTIP'] = '두 수를 나눈 나머지를 반환합니다.';

            // 숫자 속성 블록의 텍스트를 한글로 변경
            Blockly.Msg['MATH_IS_EVEN'] = '짝수';
            Blockly.Msg['MATH_IS_ODD'] = '홀수';
            Blockly.Msg['MATH_IS_PRIME'] = '소수';
            Blockly.Msg['MATH_IS_WHOLE'] = '정수';
            Blockly.Msg['MATH_IS_POSITIVE'] = '양수';
            Blockly.Msg['MATH_IS_NEGATIVE'] = '음수';
            Blockly.Msg['MATH_IS_DIVISIBLE_BY'] = '다음 수로 나누어떨어짐:';        
            
            //논리 블록 메시지 한글화
            Blockly.Msg["CONTROLS_IF_MSG_IF"] = "만약";
            Blockly.Msg["CONTROLS_IF_MSG_ELSE"] = "그렇지 않으면";
            Blockly.Msg["CONTROLS_IF_MSG_THEN"] = "실행";
            Blockly.Msg["LOGIC_BOOLEAN_TRUE"] = "참";
            Blockly.Msg["LOGIC_BOOLEAN_FALSE"] = "거짓";

            // 작업 공간 초기화
            workspace = Blockly.inject('blocklyDiv', {
                toolbox: document.getElementById('toolbox'),
                scrollbars: true,
                trashcan: true,
                theme: 'custom_theme',
                grid: {
                    spacing: 20,
                    length: 3,
                    colour: '#ccc',
                    snap: true
                },
                zoom: {
                    controls: true,
                    wheel: true,
                    startScale: 1.0,
                    maxScale: 3,
                    minScale: 0.3,
                    scaleSpeed: 1.2
                }
            });
            
            // '점수' 변수 자동 생성
            workspace.createVariable('점수', '', '점수');

            // 변수 카테고리의 flyout 수정
            const originalFlyoutCategory = Blockly.Variables.flyoutCategory;
            Blockly.Variables.flyoutCategory = function(workspace) {
                const blockList = originalFlyoutCategory(workspace);
                blockList.forEach(blockDef => {
                    if (blockDef.type === 'variables_set') {
                        blockDef.input = {
                            name: 'VALUE',
                            shadow: {
                                type: 'math_number',
                                fields: { NUM: '0' }
                            }
                        };
                    }
                });
                return blockList;
            };

            // JavaScript 생성기 초기화
            Blockly.JavaScript.init(workspace);
            Blockly.JavaScript.addReservedWords('code');
            Blockly.JavaScript.STATEMENT_PREFIX = '';

            // 변수 카테고리 스타일 설정 제거
            workspace.getToolbox().getToolboxItems().forEach(category => {
                if (category.getName() === '변수') {
                    category.getDiv().style.backgroundColor = '';  // 배경색 제거
                }
            });
        }
                
        // 블록 스타일 정의
        Blockly.Theme.defineTheme('custom_theme', {
            'base': Blockly.Themes.Classic,
            'blockStyles': {
                'hat_blocks': {
                    'hat': 'cap',
                    'colourPrimary': '#60A5FA',
                    'colourSecondary': '#93C5FD',
                    'colourTertiary': '#3B82F6'
                },
                'rounded_blocks': {
                    'colourPrimary': '#7ABB55',
                    'colourSecondary': '#8FD169',
                    'colourTertiary': '#669C46'
                },
                'repeat_blocks': {
                    'colourPrimary': '#55833C',
                    'colourSecondary': '#729665',
                    'colourTertiary': '#3D6428'
                },
                'agent_blocks': {
                    'colourPrimary': '#D83B01',
                    'colourSecondary': '#E85C33',
                    'colourTertiary': '#B32D01'
                },
                'variable_blocks': {
                    'colourPrimary': '#a41e16',
                    'colourSecondary': '#b84940',
                    'colourTertiary': '#8b1912'
                },
                'math_blocks': {
                    'colourPrimary': '#4c4d70',
                    'colourSecondary': '#666790',
                    'colourTertiary': '#363756'
                },
                'logic_blocks': {
                    'colourPrimary': '#459197',
                    'colourSecondary': '#5BA7AD',
                    'colourTertiary': '#357B81'
                }
            }
        });

        // 채팅명령어 블록 정의
        Blockly.Blocks['on_chat_command'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("채팅명령어")
                    .appendField(new Blockly.FieldTextInput("", function(newValue) {
                        // 명령어 중복 검사
                        const blocks = workspace.getTopBlocks(true);
                        const eventBlocks = blocks.filter(block => 
                            block.type === 'on_chat_command' && 
                            block.id !== this.sourceBlock_.id
                        );
                        
                        const isDuplicate = eventBlocks.some(block => 
                            block.getFieldValue('COMMAND') === newValue
                        );
                        
                        if (isDuplicate) {
                            showNotification('이미 사용 중인 명령어입니다!');
                            return null; // 변경을 취소합니다
                        }
                        
                        return newValue;
                    }), "COMMAND")
                    .appendField("입력 시");
                this.appendStatementInput('NEXT');
                this.setColour('#60A5FA');
                this.setTooltip("채팅창에 입력한 명령어로 코드를 실행합니다");
                this.setStyle('hat_blocks');
            }
        };

        // 에이전트 텔레포트 블록 정의
        Blockly.Blocks['agent_tp_pos'] = {
            init: function() {
                this.appendValueInput("POSITION")
                    .setCheck("Position")
                    .appendField("에이전트가 텔레포트:");
                this.appendDummyInput()
                    .appendField("바라보는 방향")
                    .appendField(new Blockly.FieldDropdown([
                        ["동쪽(+x)", "east"],
                        ["서쪽(-x)", "west"],
                        ["남쪽(+z)", "south"],
                        ["북쪽(-z)", "north"]
                    ]), "FACING");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#D83B01');
                this.setTooltip("에이전트를 지정된 상대 좌표로 이동시키고 특정 방향을 보게 합니다");
                this.setStyle('agent_blocks');
            }
        };

        // 에이전트 생성 블록 정의
        Blockly.Blocks['agent_spawn'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("에이전트 생성");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#D83B01');
                this.setTooltip("에이전트를 생성합니다");
                this.setStyle('agent_blocks');
            }
        };

        Blockly.Blocks['agent_tp'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("에이전트 플레이어에게 TP");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#D83B01');
                this.setTooltip("에이전트를 플레이어 위치로 이동합니다");
                this.setStyle('agent_blocks');
            }
        };

        // 에이전트 이동 명령 블록
        Blockly.Blocks['agent_move'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("에이전트")
                    .appendField(new Blockly.FieldDropdown([
                        ["앞으로", "forward"],
                        ["뒤로", "back"],
                        ["위로", "up"],
                        ["아래로", "down"],
                        ["왼쪽으로", "left"],
                        ["오른쪽으로", "right"]
                    ]), "DIRECTION");
                this.appendValueInput("DISTANCE")
                    .setCheck("Number")
                    .appendField("칸 이동하기");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#D83B01');
                this.setTooltip("에이전트를 지정된 방향으로 지정된 칸만큼 이동합니다");
                this.setStyle('agent_blocks');

                // 기본 숫자 블록 연결 (1칸)
                const numberBlock = this.workspace.newBlock('math_number');
                numberBlock.initSvg();
                numberBlock.setFieldValue('1', 'NUM');
                this.getInput('DISTANCE').connection.connect(numberBlock.outputConnection);
                numberBlock.render();
            }
        };

        // 에이전트 회전 명령 블록
        Blockly.Blocks['agent_turn'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("에이전트 회전하기")
                    .appendField(new Blockly.FieldDropdown([
                        ["왼쪽으로", "left"],
                        ["오른쪽으로", "right"]
                    ]), "DIRECTION");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#D83B01');
                this.setTooltip("에이전트를 지정된 방향으로 회전합니다");
                this.setStyle('agent_blocks');
            }
        };

        // 에이전트 블록 파괴 명령 블록
        Blockly.Blocks['agent_destroy'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("에이전트")
                    .appendField(new Blockly.FieldDropdown([
                        ["앞의", "forward"],
                        ["뒤의", "back"],
                        ["왼쪽의", "left"],
                        ["오른쪽의", "right"],
                        ["위의", "up"],
                        ["아래의", "down"]
                    ]), "DIRECTION")
                    .appendField("블록 파괴하기");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#D83B01');
                this.setTooltip("에이전트가 지정된 방향의 블록을 파괴합니다");
                this.setStyle('agent_blocks');
            }
        };

        // 에이전트 공격 명령 블록
        Blockly.Blocks['agent_attack'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("에이전트 공격하기");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#D83B01');
                this.setTooltip("에이전트가 앞의 대상을 공격합니다");
                this.setStyle('agent_blocks');
            }
        };

        // 에이전트 블록 설치 명령 블록
        Blockly.Blocks['agent_place'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("에이전트")
                    .appendField(new Blockly.FieldDropdown([
                        ["앞에", "forward"],
                        ["뒤에", "back"],
                        ["왼쪽에", "left"],
                        ["오른쪽에", "right"],
                        ["위에", "up"],
                        ["아래에", "down"]
                    ]), "DIRECTION")
                    .appendField("블록 설치하기");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#D83B01');
                this.setTooltip("에이전트가 지정된 방향에 블록을 설치합니다");
                this.setStyle('agent_blocks');
            }
        };

        // 에이전트 슬롯 선택 블록
        Blockly.Blocks['agent_set_slot'] = {
            init: function() {
                this.appendValueInput("SLOT")
                    .setCheck("Number")
                    .appendField("에이전트 슬롯 선택");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#D83B01');
                this.setTooltip("에이전트의 인벤토리 슬롯을 선택합니다");
                this.setStyle('agent_blocks');

                // 기본 숫자 블록 연결 (슬롯 1)
                const numberBlock = this.workspace.newBlock('math_number');
                numberBlock.initSvg();
                numberBlock.setFieldValue('1', 'NUM');
                this.getInput('SLOT').connection.connect(numberBlock.outputConnection);
                numberBlock.render();
            }
        };

        // 에이전트 모든 아이템 버리기 명령 블록
        Blockly.Blocks['agent_drop_all'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("에이전트 모든 아이템 버리기");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#D83B01');
                this.setTooltip("에이전트가 모든 아이템을 버립니다");
                this.setStyle('agent_blocks');
            }
        };

        // 에이전트 선택 슬롯 아이템 버리기 명령 블록
        Blockly.Blocks['agent_drop_slot'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("에이전트 선택 슬롯 아이템 버리기");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#D83B01');
                this.setTooltip("에이전트가 선택된 슬롯의 아이템을 버립니다");
                this.setStyle('agent_blocks');
            }
        };

        // 아이템 줍기 블록 정의
        Blockly.Blocks['agent_collect'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("에이전트 아이템 줍기");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#D83B01');
                this.setTooltip("에이전트가 주변의 아이템을 주웁니다");
                this.setStyle('agent_blocks');
            }
        };
        
        // 에이전트 경작 블록 정의
        Blockly.Blocks['agent_till'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("에이전트")
                    .appendField(new Blockly.FieldDropdown([
                        ["앞의", "forward"],
                        ["뒤의", "back"],
                        ["왼쪽의", "left"],
                        ["오른쪽의", "right"],
                        ["위의", "up"],
                        ["아래의", "down"]
                    ]), "DIRECTION")
                    .appendField("땅 경작하기");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#D83B01');
                this.setTooltip("에이전트가 지정된 방향의 땅을 경작합니다");
                this.setStyle('agent_blocks');
            }
        };

        // 커스텀 반복 명령 블록
        Blockly.Blocks['custom_repeat'] = {
            init: function() {
                this.appendValueInput("TIMES")
                    .setCheck("Number")
                    .appendField("반복하기");
                this.appendStatementInput('DO');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#55833C');
                this.setTooltip("지정된 횟수만큼 명령을 반복합니다");
                this.setStyle('repeat_blocks');

                // 기본 숫자 블록 연결 (4회)
                const numberBlock = this.workspace.newBlock('math_number');
                numberBlock.initSvg();
                numberBlock.setFieldValue('4', 'NUM');
                this.getInput('TIMES').connection.connect(numberBlock.outputConnection);
                numberBlock.render();
            }
        };
        
        // 변수 관련 코드 생성기 등록
        Blockly.JavaScript['variables_get'] = function(block) {
            const varName = Blockly.JavaScript.nameDB_.getName(block.getFieldValue('VAR'), Blockly.VARIABLE_CATEGORY_NAME);
            return [varName, Blockly.JavaScript.ORDER_ATOMIC];
        };

        Blockly.JavaScript['variables_set'] = function(block) {
            const argument0 = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_ASSIGNMENT) || '0';
            const varName = Blockly.JavaScript.nameDB_.getName(block.getFieldValue('VAR'), Blockly.VARIABLE_CATEGORY_NAME);
            return `${varName} = ${argument0};\n`;
        };

        // 변수 블록 초기화 그림자 블록 추가
        const originalVariableInit = Blockly.Blocks['variables_set'].init;
        Blockly.Blocks['variables_set'].init = function() {
            originalVariableInit.call(this);
            // shadow 블록 추가
            const input = this.getInput('VALUE');
            if (input && !input.connection.targetConnection) {
                const shadow = this.workspace.newBlock('math_number');
                shadow.setShadow(true);
                shadow.initSvg();
                shadow.setFieldValue('0', 'NUM');
                input.connection.connect(shadow.outputConnection);
                shadow.render();
            }
        };

        // 기존의 블록 초기화 코드 제거 (shadow 블록으로 대체)
        Blockly.Blocks['agent_move'].init = function() {
            this.appendDummyInput()
                .appendField("에이전트")
                .appendField(new Blockly.FieldDropdown([
                    ["앞으로", "forward"],
                    ["뒤로", "back"],
                    ["위로", "up"],
                    ["아래로", "down"],
                    ["왼쪽으로", "left"],
                    ["오른쪽으로", "right"]
                ]), "DIRECTION");
            this.appendValueInput("DISTANCE")
                .setCheck("Number")
                .appendField("칸 이동하기");
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour('#D83B01');
            this.setTooltip("에이전트를 지정된 방향으로 지정된 칸만큼 이동합니다");
            this.setStyle('agent_blocks');
        };

        // 에이전트 슬롯 선택 블록 초기화 수정
        Blockly.Blocks['agent_set_slot'].init = function() {
            this.appendValueInput("SLOT")
                .setCheck("Number")
                .appendField("에이전트 슬롯 선택");
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour('#D83B01');
            this.setTooltip("에이전트의 인벤토리 슬롯을 선택합니다");
            this.setStyle('agent_blocks');
        };

        // 커스텀 반복 블록 초기화 수정
        Blockly.Blocks['custom_repeat'].init = function() {
            this.appendValueInput("TIMES")
                .setCheck("Number")
                .appendField("반복하기");
            this.appendStatementInput('DO');
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour('#55833C');
            this.setTooltip("지정된 횟수만큼 명령을 반복합니다");
            this.setStyle('repeat_blocks');
        };
            
        // 좌표 블록 정의
        Blockly.defineBlocksWithJsonArray([{
            "type": "coordinate_pos",
            "message0": "~%1~%2~%3",
            "args0": [
                {
                    "type": "input_value",
                    "name": "X",
                    "check": "Number",
                    "align": "CENTRE"
                },
                {
                    "type": "input_value",
                    "name": "Y",
                    "check": "Number",
                    "align": "CENTRE"
                },
                {
                    "type": "input_value",
                    "name": "Z",
                    "check": "Number",
                    "align": "CENTRE"
                }
            ],
            "output": "Position",
            "colour": '#69b090',
            "tooltip": "플레이어 기준의 상대 좌표를 지정합니다",
            "inputsInline": true
        }]);

        // 절대좌표 블록 정의
        Blockly.defineBlocksWithJsonArray([{
            "type": "world_pos",
            "message0": "월드%1%2%3",
            "args0": [
                {
                    "type": "input_value",
                    "name": "X",
                    "check": "Number",
                    "align": "CENTRE"
                },
                {
                    "type": "input_value",
                    "name": "Y",
                    "check": "Number",
                    "align": "CENTRE"
                },
                {
                    "type": "input_value",
                    "name": "Z",
                    "check": "Number",
                    "align": "CENTRE"
                }
            ],
            "output": "Position",
            "colour": '#69b090',
            "tooltip": "월드의 절대 좌표를 지정합니다",
            "inputsInline": true
        }]);

        // XML 툴박스에서 위치 블록 정의 수정
        const positionCategory = document.querySelector('category[name="위치"]');
        positionCategory.innerHTML = `
            <block type="coordinate_pos">
                <value name="X">
                    <shadow type="math_number">
                        <field name="NUM">0</field>
                    </shadow>
                </value>
                <value name="Y">
                    <shadow type="math_number">
                        <field name="NUM">0</field>
                    </shadow>
                </value>
                <value name="Z">
                    <shadow type="math_number">
                        <field name="NUM">0</field>
                    </shadow>
                </value>
            </block>
            <block type="world_pos">
                <value name="X">
                    <shadow type="math_number">
                        <field name="NUM">0</field>
                    </shadow>
                </value>
                <value name="Y">
                    <shadow type="math_number">
                        <field name="NUM">0</field>
                    </shadow>
                </value>
                <value name="Z">
                    <shadow type="math_number">
                        <field name="NUM">0</field>
                    </shadow>
                </value>
            </block>
        `;

        // 좌표 블록 초기화 수정
        Blockly.Blocks['coordinate_pos'].init = function() {
            this.jsonInit({
                "type": "coordinate_pos",
                "message0": "~%1~%2~%3",
                "args0": [
                    {
                        "type": "input_value",
                        "name": "X",
                        "check": "Number",
                        "align": "CENTRE"
                    },
                    {
                        "type": "input_value",
                        "name": "Y",
                        "check": "Number",
                        "align": "CENTRE"
                    },
                    {
                        "type": "input_value",
                        "name": "Z",
                        "check": "Number",
                        "align": "CENTRE"
                    }
                ],
                "output": "Position",
                "colour": '#69b090',
                "tooltip": "플레이어 기준의 상대 좌표를 지정합니다",
                "inputsInline": true
            });

            // 이 블록이 다른 블록에 의해 생성된 것이 아닐 때만 숫자 블록 연결
            if (!this.isInFlyout && !this.isInMutator && !this.workspace.isDragging) {
                // X, Y, Z 입력에 기본값 0 설정
                const numberBlockX = this.workspace.newBlock('math_number');
                numberBlockX.initSvg();
                numberBlockX.setFieldValue('0', 'NUM');
                
                const numberBlockY = this.workspace.newBlock('math_number');
                numberBlockY.initSvg();
                numberBlockY.setFieldValue('0', 'NUM');
                
                const numberBlockZ = this.workspace.newBlock('math_number');
                numberBlockZ.initSvg();
                numberBlockZ.setFieldValue('0', 'NUM');
                
                this.getInput('X').connection.connect(numberBlockX.outputConnection);
                this.getInput('Y').connection.connect(numberBlockY.outputConnection);
                this.getInput('Z').connection.connect(numberBlockZ.outputConnection);
                
                numberBlockX.render();
                numberBlockY.render();
                numberBlockZ.render();
            }
        };

        // 절대좌표 블록 초기화 수정
        Blockly.Blocks['world_pos'].init = function() {
            this.jsonInit({
                "type": "world_pos",
                "message0": "월드%1%2%3",
                "args0": [
                    {
                        "type": "input_value",
                        "name": "X",
                        "check": "Number",
                        "align": "CENTRE"
                    },
                    {
                        "type": "input_value",
                        "name": "Y",
                        "check": "Number",
                        "align": "CENTRE"
                    },
                    {
                        "type": "input_value",
                        "name": "Z",
                        "check": "Number",
                        "align": "CENTRE"
                    }
                ],
                "output": "Position",
                "colour": '#69b090',
                "tooltip": "월드의 절대 좌표를 지정합니다",
                "inputsInline": true
            });
        };

        // 좌표 블록 코드 생성기
        Blockly.JavaScript.forBlock['coordinate_pos'] = function(block) {
            const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            const z = Blockly.JavaScript.valueToCode(block, 'Z', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            return [`{x: ${x}, y: ${y}, z: ${z}, isAbsolute: false}`, Blockly.JavaScript.ORDER_MEMBER];
        };

        // 절대좌표 블록 코드 생성기
        Blockly.JavaScript.forBlock['world_pos'] = function(block) {
            const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            const z = Blockly.JavaScript.valueToCode(block, 'Z', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            return [`{x: ${x}, y: ${y}, z: ${z}, isAbsolute: true}`, Blockly.JavaScript.ORDER_MEMBER];
        };       
        
        // 에이전트 텔레포트 코드 생성기
        Blockly.JavaScript['agent_tp_pos'] = function(block) {
            const position = Blockly.JavaScript.valueToCode(block, 'POSITION', Blockly.JavaScript.ORDER_MEMBER);
            const facing = block.getFieldValue('FACING');
            
            // 좌표 블록이 연결되지 않은 경우 기본 tp 명령 실행
            if (!position) {
                return `await new Promise(resolve => {
                    socket.emit("tp");
                    setTimeout(resolve, 150);
                });\n`;
            }
            
            // 좌표 블록이 연결된 경우 tpPos 명령 실행
            return `await new Promise(resolve => {
                const pos = ${position};
                socket.emit("tpPos", {
                    x: pos.x, 
                    y: pos.y, 
                    z: pos.z, 
                    facing: "${facing}",
                    isAbsolute: pos.isAbsolute
                });
                setTimeout(resolve, 150);
            });\n`;
        };

        // 이동 명령 코드 생성기
        Blockly.JavaScript['agent_move'] = function(block) {
            const direction = block.getFieldValue('DIRECTION');
            const distance = Blockly.JavaScript.valueToCode(block, 'DISTANCE', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            let command = '';
            let delay = 200;
            
            switch(direction) {
                case 'forward': command = 'goforward'; break;
                case 'back': command = 'goBack'; break;
                case 'up': command = 'goUp'; break;
                case 'down': command = 'goDown'; break;
                case 'left': command = 'goLeft'; break;
                case 'right': command = 'goRight'; break;
            }
            
            // JavaScript 코드 반환 시 async 함수를 사용하도록 수정
            return `
                await (async () => {
                    console.log('\\n=== 이동 명령 실행 시작 ===');
                    console.log('방향: ${direction}, 거리: ${distance}칸');
                    console.log('------------------------');

                    for (let i = 0; i < ${distance}; i++) {
                        if (shouldStop) {
                            console.log('실행이 중단되었습니다.');
                            return;
                        }
                        await new Promise(resolve => {
                            socket.emit("${command}");
                            setTimeout(resolve, ${delay});
                        });
                    }

                    console.log('=== 이동 완료 ===\\n');
                })();
            `;
        };
        
        // 커팅 명령어 이벤트 코드 생성
        Blockly.JavaScript['on_chat_command'] = function(block) {
            const command = block.getFieldValue('COMMAND');
            const blockId = block.id;  // 블록의 고유 ID
            const nextCode = Blockly.JavaScript.statementToCode(block, 'NEXT');
            
            // 명령어와 블록 ID를 함께 전송
            socket.emit('updateExecutionCommand', { command, blockId });
            return nextCode;
        };

        // 커스텀 반복 명령 블록의 JavaScript 코드 생성기
        Blockly.JavaScript['custom_repeat'] = function(block) {
            const times = Blockly.JavaScript.valueToCode(block, 'TIMES', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            let innerBlock = block.getInputTargetBlock('DO');
            let innerCode = '';
            
            while (innerBlock) {
                innerCode += Blockly.JavaScript[innerBlock.type](innerBlock);
                innerBlock = innerBlock.getNextBlock();
            }

            return `
                await (async () => {
                    for (let i = 0; i < ${times}; i++) {
                        if (shouldStop) {
                            console.log('실행이 중단되었습니다.');
                            return;
                        }
                        console.log('\\n=== 반복 실행:', i + 1, '===');
                        ${innerCode}
                        // 각 반복 사이에 대기 시간 추가
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                })();
            `;
        };

        // XML 툴박스에서 기존 controls_repeat를 custom_repeat로 변경
        const toolbox = document.getElementById('toolbox');
        const basicCategory = toolbox.querySelector('category[name="블록"]');
        const repeatBlock = basicCategory.querySelector('block[type="controls_repeat"]');
        if (repeatBlock) {
            repeatBlock.setAttribute('type', 'custom_repeat');
        }

        // 회전 명령 코드 생성기
        Blockly.JavaScript['agent_turn'] = function(block) {
            const direction = block.getFieldValue('DIRECTION');
            let command = direction === 'left' ? 'rotateLeft' : 'rotateRight';
            return `await new Promise(resolve => {
                socket.emit("${command}");
                setTimeout(resolve, 50);
            });\n`;
        };

        // 에이전트 생성 명령 코드 생성기
        Blockly.JavaScript['agent_spawn'] = function(block) {
            return `await new Promise(resolve => {
                socket.emit("spawn");
                setTimeout(resolve, 150);
            });\n`;
        };

        // 에이전트 텔레포트 명령 코드 생성기
        Blockly.JavaScript['agent_tp'] = function(block) {
            return `await new Promise(resolve => {
                socket.emit("tp");
                setTimeout(resolve, 150);
            });\n`;
        };

        // 블록 파괴 명령 코드 생성기
        Blockly.JavaScript['agent_destroy'] = function(block) {
            const direction = block.getFieldValue('DIRECTION');
            return `await new Promise(resolve => {
                socket.emit("destroy", "${direction}");
                setTimeout(resolve, 150);
            });\n`;
        };

        // 에이전트 공격 명령 코드 생성기
        Blockly.JavaScript['agent_attack'] = function(block) {
            return `await new Promise(resolve => {
                socket.emit("attack");
                setTimeout(resolve, 150);
            });\n`;
        };

        // 블록 설치 명령 코드 생성기
        Blockly.JavaScript['agent_place'] = function(block) {
            const direction = block.getFieldValue('DIRECTION');
            return `await new Promise(resolve => {
                socket.emit("place", "${direction}");
                setTimeout(resolve, 150);
            });\n`;
        };

        // 에이전트 슬롯 선택 명령 코드 생성기
        Blockly.JavaScript['agent_set_slot'] = function(block) {
            const slot = Blockly.JavaScript.valueToCode(block, 'SLOT', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            return `await new Promise(resolve => {
                socket.emit("setSlot", ${slot});
                setTimeout(resolve, 150);
            });\n`;
        };

        // 에이전트 모든 아이템 버리기 명령 코드 생성기
        Blockly.JavaScript['agent_drop_all'] = function(block) {
            return `await new Promise(resolve => {
                socket.emit("dropAll");
                setTimeout(resolve, 150);
            });\n`;
        };

        // 에이전트 슬롯 아이템 버리기 명령 코드 생성기
        Blockly.JavaScript['agent_drop_slot'] = function(block) {
            return `await new Promise(resolve => {
                socket.emit("dropSlotItem");
                setTimeout(resolve, 150);
            });\n`;
        };

        // 아이템 줍기 코드 생성기
        Blockly.JavaScript['agent_collect'] = function(block) {
            return `await new Promise(resolve => {
                socket.emit("collect");
                setTimeout(resolve, 150);
            });\n`;
        };

        // 블록 모양 추가
        Blockly.BlockSvg.START_HAT_PATH = 'c 25,-22 71,-22 96,0';
        Blockly.BlockSvg.START_HAT_HIGHLIGHT_PATH = 'c 25,-22 71,-22 96,0';

        // 경작 명령 코드 생성기
        Blockly.JavaScript['agent_till'] = function(block) {
            const direction = block.getFieldValue('DIRECTION');
            return `await new Promise(resolve => {
                socket.emit("till", "${direction}");
                setTimeout(resolve, 150);
            });\n`;
        };

        // 모든 명령 블록의 코드 생성기 수정
        const originalGenerators = {
            'agent_move': Blockly.JavaScript['agent_move'],
            'agent_turn': Blockly.JavaScript['agent_turn'],
            'agent_destroy': Blockly.JavaScript['agent_destroy'],
            'agent_place': Blockly.JavaScript['agent_place'],
            'agent_spawn': Blockly.JavaScript['agent_spawn'],
            'agent_tp': Blockly.JavaScript['agent_tp'],
            'agent_tp_pos': Blockly.JavaScript['agent_tp_pos'],
            'agent_attack': Blockly.JavaScript['agent_attack'],
            'agent_set_slot': Blockly.JavaScript['agent_set_slot'],
            'agent_drop_all': Blockly.JavaScript['agent_drop_all'],
            'agent_drop_slot': Blockly.JavaScript['agent_drop_slot'],
            'agent_collect': Blockly.JavaScript['agent_collect'],
            'agent_till': Blockly.JavaScript['agent_till'],
            'coordinate_pos': Blockly.JavaScript['coordinate_pos']
        };

        // controls_if 블록의 코드 생성기 수정
        Blockly.JavaScript['controls_if'] = function(block) {
            // 조건문과 실행 코드 생성
            let n = 0;
            let code = '', conditionCode;
            do {
                conditionCode = Blockly.JavaScript.valueToCode(block, 'IF' + n,
                    Blockly.JavaScript.ORDER_NONE) || 'false';
                
                // DO 입력의 내부 블록들을 직접 처리
                let branchBlock = block.getInputTargetBlock('DO' + n);
                let branchCode = '';
                while (branchBlock) {
                    branchCode += Blockly.JavaScript[branchBlock.type](branchBlock);
                    branchBlock = branchBlock.getNextBlock();
                }
                
                code += (n == 0 ? 'if (' : 'else if (') + conditionCode + ') {\n' + branchCode + '}';
                ++n;
            } while (block.getInput('IF' + n));

            if (block.getInput('ELSE')) {
                // ELSE 입력의 내부 블록들을 직접 처리
                let elseBlock = block.getInputTargetBlock('ELSE');
                let elseCode = '';
                while (elseBlock) {
                    elseCode += Blockly.JavaScript[elseBlock.type](elseBlock);
                    elseBlock = elseBlock.getNextBlock();
                }
                code += ' else {\n' + elseCode + '}';
            }
            
            // 비동기 처리를 위해 async 함수로 감싸기
            return `
                await (async () => {
                    ${code}
                })();
            `;
        };

        // 각 명령 블록의 코드 생성기를 중지 체크가 포함된 버전으로 교체
        Object.keys(originalGenerators).forEach(blockType => {
            if (blockType === 'coordinate_pos') return;  // 좌표 블록은 건너뛰기
            const originalGenerator = originalGenerators[blockType];
            Blockly.JavaScript[blockType] = function(block) {
                const originalCode = originalGenerator.call(this, block);
                return `
                    await (async () => {
                        if (shouldStop) {
                            console.log('실행이 중단되었습니다.');
                            return;
                        }
                        console.log('명령 실행:', '${blockType}');
                        ${originalCode}
                        // 각 명령 사이에 추가 대기 시간
                        await new Promise(resolve => setTimeout(resolve, 50));
                    })();
                `;
            };
        });

        // 반복 블록의 코드 생성기도 중지 체크 포함
        const originalRepeatGenerator = Blockly.JavaScript['custom_repeat'];
        Blockly.JavaScript['custom_repeat'] = function(block) {
            const times = Blockly.JavaScript.valueToCode(block, 'TIMES', Blockly.JavaScript.ORDER_ATOMIC) || '0';
            let innerBlock = block.getInputTargetBlock('DO');
            let innerCode = '';
            
            while (innerBlock) {
                innerCode += Blockly.JavaScript[innerBlock.type](innerBlock);
                innerBlock = innerBlock.getNextBlock();
            }

            return `
                await (async () => {
                    for (let i = 0; i < ${times}; i++) {
                        if (shouldStop) {
                            console.log('실행이 중단되었습니다.');
                            return;
                        }
                        console.log('\\n=== 반복 실행:', i + 1, '===');
                        ${innerCode}
                        // 각 반복 사이에 대기 시간 추가
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                })();
            `;
        };

        // 채팅창에 말하기 명령 블록 수정
        Blockly.Blocks['text_print'] = {
            init: function() {
                this.appendValueInput('TEXT')
                    .setCheck(['String', 'Array'])  // String과 Array 모두 받을 수 있도록 설정
                    .appendField("채팅창에 말하기");
                
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour('#60A5FA');
                this.setTooltip("채팅창에 지정된 메시지를 표시합니다");
                this.setStyle('hat_blocks');
            }
        };

        // text_join 블록 초기화 수정
        Blockly.Blocks['text_join'] = {
            init: function() {
                this.setStyle('hat_blocks');  // 플레이어 카테고리와 같은 스타일 사용
                this.setColour('#60A5FA');    // 플레이어 카테고리와 같은 색상
                this.itemCount_ = 2;
                this.updateShape_();
                this.setOutput(true, 'String');
                this.setTooltip("여러 텍스트를 하나로 합칩니다");
            },

            mutationToDom: function() {
                const container = Blockly.utils.xml.createElement('mutation');
                container.setAttribute('items', this.itemCount_);
                return container;
            },

            domToMutation: function(xmlElement) {
                this.itemCount_ = parseInt(xmlElement.getAttribute('items'), 10);
                this.updateShape_();
            },

            updateShape_: function() {
                // 첫 번째 입력값은 "텍스트 합치기:" 레이블과 함께
                if (this.getInput('ADD0')) {
                    this.removeInput('ADD0');
                }
                this.appendValueInput('ADD0')
                    .setCheck('String')
                    .appendField('텍스트 합치기:');

                // 나머지 입력값들
                for (let i = 1; i < this.itemCount_; i++) {
                    if (this.getInput('ADD' + i)) {
                        this.removeInput('ADD' + i);
                    }
                    this.appendValueInput('ADD' + i)
                        .setCheck('String')
                        .appendField('더하기');
                }
            }
        };


        // text_join 블록의 코드 생성기 수정
        Blockly.JavaScript['text_join'] = function(block) {
            // 입력된 텍스트들을 배열로 가져옴
            const values = [];
            for (let i = 0; i < block.itemCount_; i++) {
                const valueCode = Blockly.JavaScript.valueToCode(block, 'ADD' + i,
                    Blockly.JavaScript.ORDER_NONE) || '\'\'';
                values.push(valueCode);
            }
            // 텍스트들을 공백으로 연결
            return [values.join(' + \' \' + '), Blockly.JavaScript.ORDER_ADDITION];
        };

        // 채팅창에 말하기 블록의 코드 생성기
        Blockly.JavaScript['text_print'] = function(block) {
            const msg = Blockly.JavaScript.valueToCode(block, 'TEXT',
                Blockly.JavaScript.ORDER_NONE) || '\'\'';
            
            return `
                await (async () => {
                    if (shouldStop) {
                        console.log('실행이 중단되었습니다.');
                        return;
                    }
                    await new Promise(resolve => {
                        socket.emit('say', ${msg});
                        setTimeout(resolve, 150);
                    });
                })();
            `;
        };

        // 알림 메시지 표시 함수
        function showNotification(message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.classList.add('show');
            setTimeout(() => {
                    notification.classList.remove('show');
                }, 3000);
            }

        // 페이지 로드 시 실행
        document.addEventListener('DOMContentLoaded', function() {
            initBlockly();
            
            // 작업 영역의 변경사항을 감지하여 명령어 업데이트
            workspace.addChangeListener(function(event) {
                if (event.type == Blockly.Events.BLOCK_CHANGE || 
                    event.type == Blockly.Events.BLOCK_CREATE || 
                    event.type == Blockly.Events.BLOCK_DELETE) {
                    
                    const blocks = workspace.getTopBlocks(true);
                    const eventBlocks = blocks.filter(block => block.type === 'on_chat_command');
                    
                    // 중복 명령어 검사
                    const commands = new Set();
                    eventBlocks.forEach(block => {
                        const command = block.getFieldValue('COMMAND');
                        if (commands.has(command)) {
                            // 중복된 명령어가 있으면 경고 표시
                            showNotification('중복된 명령어가 있습니다!');
                            return;
                        }
                        commands.add(command);
                        
                        const blockId = block.id;
                        socket.emit('updateExecutionCommand', { command, blockId });
                    });
                }
            });
        });
        
        // 실행 중지 함수
        function stopExecution() {
            if (isExecuting) {
                shouldStop = true;
                showNotification('실행을 중지합니다...');
            }
        }

        // 명령어 실행 이벤트 처리
        socket.on('executeCommands', async function(blockId) {
            if (isExecuting) {
                showNotification('이미 실행 중입니다.');
                return;
            }
            
            const blocks = workspace.getTopBlocks(true);
            const eventBlocks = blocks.filter(block => block.type === 'on_chat_command');
            
            const targetBlock = eventBlocks.find(block => block.id === blockId);
            if (targetBlock) {
                try {
                    isExecuting = true;
                    shouldStop = false;
                    console.log('\n=== 명령어 실행 시작 ===');
                    console.log('블록 ID:', blockId);
                    console.log('------------------------');
                    showNotification('명령을 실행합니다...');
                    
                    let code = '';
                    let nextBlock = targetBlock.getInputTargetBlock('NEXT');
                    
                    while (nextBlock) {
                        if (shouldStop) {
                            console.log('실행이 중단되었습니다.');
                            showNotification('실행이 중단되었습니다.');
                            isExecuting = false;
                            return;
                        }
                        
                        // 코드 생성기 재초기화
                        Blockly.JavaScript.init(workspace);
                        
                        if (Blockly.JavaScript[nextBlock.type]) {
                            code += Blockly.JavaScript[nextBlock.type](nextBlock);
                        } else {
                            console.warn(`블록 타입 "${nextBlock.type}"에 대한 코드 생성기가 없습니다.`);
                        }
                        
                        nextBlock = nextBlock.getNextBlock();
                    }
                    
                    // 디버깅을 위한 생성된 코드 출력
                    console.log('생성된 코드:', code);
                    
                    await eval('(async () => { ' + code + ' })()');
                    console.log('------------------------');
                    console.log('=== 실행 완료 ===\n');
                    showNotification('실행이 완료되었습니다.');
                } catch (e) {
                    console.log('❌ 실행 중 오류 발생');
                    console.error('오류 내용:', e);
                    showNotification('실행 중 오류가 발생했습니다: ' + e.message);
                } finally {
                    isExecuting = false;
                    shouldStop = false;
                }
            } else {
                console.log('❌ 명령어 블록을 찾을 수 없음');
                showNotification('해당 명령어 블록을 찾을 수 없습니다.');
            }
        });

        
    </script>
</body>
</html>